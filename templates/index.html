<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8">
  <title>Somewhere Dispatch</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
  body {
    font-family: 'VT323', monospace;
    background-color: black;
    color: #00ffcc;
    margin: 0;
    overflow-y: scroll;
    word-wrap: break-word;
    padding: 1rem;
    font-size: 16px;
  }

  body::before {
    content: "";
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    background: repeating-linear-gradient(
      to bottom,
      rgba(0,0,0,0.1) 0px,
      rgba(0,0,0,0.15) 1px,
      transparent 2px
    );
    pointer-events: none;
    z-index: 9999;
    animation: flicker 1s infinite;
  }

  @keyframes flicker {
    0%, 100% { opacity: 0.03; }
    50% { opacity: 0.06; }
  }

  .fade-bottom {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 500px;
    background: linear-gradient(to bottom, transparent, black 100%);
    pointer-events: none;
    z-index: 999;
  }

  header {
    position: fixed;
    top: 10px; left: 10px;
    z-index: 20;
  }

  button {
    background-color: #0f0f0f;
    color: #00ff99;
    border: 1px solid #00ff99;
    padding: 5px 10px;
    font-family: monospace;
    cursor: pointer;
  }

  .center-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 10vh 0;
  }

  .dispatch-text {
    color: #ccc;
    font-size: 1.8em;
    padding: 12px 24px;
    text-align: center;
    max-width: 90vw;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    position: relative;
    min-height: 2em;
    text-shadow: 0 0 1px #00ffcc, 0 0 4px #004d4d;
  }

  .dispatch-text::after {
    content: attr(data-glitch);
    position: absolute;
    left: 1px;
    top: 1px;
    color: #ff00ff;
    opacity: 0.03;
    mix-blend-mode: lighten;
    pointer-events: none;
    z-index: -1;
  }

  .dispatch-image,
  .history-image {
    display: block;
    margin: 0 auto;
    max-width: 290vw;
    max-height: 90vh;
    object-fit: contain;
    border-radius: 4px;
  }

.history-feed {
  display: center;
  flex-direction: column;
  align-items: center;
  padding: 100px 20px;
  max-width: 1500px;
  margin: 0 auto;
}
.dispatch-block {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 800px;
  margin-bottom: 60px;
  text-align: center;
}

  @media (max-width: 600px) {
    .dispatch-text {
      font-size: .7em;
      padding: 1rem;
      line-height: 1.5;
      text-align: left;
      max-width: 95vw;
      margin: 0 auto;
      word-break: break-word;
    }
  }

  .consequence-box {
    background: #fffbe6;
    color: #b85c00;
    border: 2px solid #ffbb33;
    border-radius: 6px;
    margin: 1em 0;
    padding: 0.7em 1em;
    font-weight: bold;
    font-size: 1.1em;
    box-shadow: 0 2px 8px #ffbb3340;
    animation: pulse-fade 1.1s cubic-bezier(0.4,0,0.2,1);
    transition: background 0.3s, color 0.3s, border 0.3s, opacity 0.3s;
  }
  @keyframes pulse-fade {
    0% { background: #fffbe6; color: #b85c00; border-color: #ffbb33; opacity: 0.2; }
    30% { background: #ffbb33; color: #222; border-color: #ffbb33; opacity: 1; }
    60% { background: #fffbe6; color: #b85c00; border-color: #ffbb33; opacity: 1; }
    100% { background: #fffbe6; color: #b85c00; border-color: #ffbb33; opacity: 1; }
  }
</style>

</head>
<body>
  <div class="fade-bottom"></div>
  <header>
    <form method="POST" action="/generate" style="display:inline;">
      <button type="submit">üõ∞Ô∏è Generate Dispatch</button>
    </form>
    <button onclick="toggleSettings()">‚öôÔ∏è Settings</button>
    <select id="promptSelector" onchange="switchPrompt(this.value)"></select>
  </header>
  <div class="center-container" id="live-container">
    <div class="dispatch-text" id="live-dispatch"></div>
    <img class="dispatch-image" id="live-image" src="" alt="Latest Dispatch Image">
  </div>
  <div class="history-feed" id="history-feed"></div>
<script>
let lastDispatchId = null;

async function loadPromptSets() {
  try {
    const res = await fetch('/available_prompt_sets');
    const sets = await res.json();
    const selector = document.getElementById("promptSelector");
    sets.forEach(name => {
      const option = document.createElement("option");
      option.value = name;
      option.textContent = name;
      selector.appendChild(option);
    });
  } catch (err) {
    console.error("Failed to load prompt sets:", err);
  }
}

async function switchPrompt(name) {
  try {
    const res = await fetch(`/set_prompt/${name}`);
    if (!res.ok) throw new Error("Bad prompt switch");
    console.log("Switched to:", name);
  } catch (err) {
    alert("Failed to switch prompt set.");
    console.error(err);
  }
}

function isConsequenceText(text) {
  if (!text) return false;
  const keywords = [
    'consequence', 'danger', 'alert', 'event', 'mutation', 'alliance', 'chaos', 'injury', 'critical', 'warning', 'disaster', 'explosion', 'panic', 'contamination', 'artifact', 'ancient', 'storm', 'hostile', 'rumor', 'evidence', 'mutation', 'leader', 'broadcast', 'rescue', 'raid', 'sabotage', 'betrayal'
  ];
  const lower = text.toLowerCase();
  return keywords.some(k => lower.includes(k));
}

function renderDispatchText(text) {
  if (isConsequenceText(text)) {
    return `<div class="consequence-box">‚ö†Ô∏è ${text}</div>`;
  }
  return `<div class="dispatch-text">${text}</div>`;
}

async function loadInitialHistory() {
  try {
    const res = await fetch('/history');
    const history = await res.json();
    if (!history.length) return;

    const liveImage = document.getElementById('live-image');
    const liveText = document.getElementById('live-dispatch');

    const latest = history[0];
    liveText.innerHTML = renderDispatchText(latest.dispatch);
    liveText.setAttribute("data-glitch", latest.dispatch);
    lastDispatchId = latest.timestamp;

    if (latest.image_url) {
      liveImage.src = latest.image_url;
      liveImage.style.display = "block";
    } else {
      liveImage.src = "";
      liveImage.style.display = "none";
    }

    const feed = document.getElementById("history-feed");
    history.slice(1).forEach(entry => {
      const block = document.createElement("div");
      block.className = "dispatch-block";

      const textDiv = document.createElement("div");
      textDiv.className = "dispatch-text";
      textDiv.setAttribute("data-glitch", entry.dispatch);
      textDiv.innerHTML = renderDispatchText(entry.dispatch);
      block.appendChild(textDiv);

      if (entry.image_url) {
        const img = document.createElement("img");
        img.className = "history-image";
        img.src = entry.image_url;
        img.alt = "Dispatch Image";
        block.appendChild(img);
      }

      feed.appendChild(block);
    });
  } catch (err) {
    console.error("Failed to load initial history:", err);
  }
}

async function pollLatest() {
  try {
    const res = await fetch('/latest');
    const data = await res.json();
    if (!data || !data.dispatch || !data.timestamp) return;

    const liveImage = document.getElementById('live-image');
    const liveText = document.getElementById('live-dispatch');

    if (lastDispatchId && lastDispatchId !== data.timestamp) {
      const historyFeed = document.getElementById("history-feed");
      const block = document.createElement("div");
      block.className = "dispatch-block";

      const textDiv = document.createElement("div");
      textDiv.className = "dispatch-text";
      textDiv.setAttribute("data-glitch", liveText.innerText);
      textDiv.innerHTML = renderDispatchText(liveText.innerText);
      block.appendChild(textDiv);

      if (liveImage.src) {
        const img = document.createElement("img");
        img.className = "history-image";
        img.src = liveImage.src;
        img.alt = "Previous Dispatch Image";
        block.appendChild(img);
      }

      historyFeed.insertBefore(block, historyFeed.firstChild);
    }

    // Live update
    liveText.innerHTML = renderDispatchText(data.dispatch);
    liveText.setAttribute("data-glitch", data.dispatch);

    if (data.image_url) {
      liveImage.src = data.image_url;
      liveImage.style.display = "block";
    } else {
      liveImage.src = "";
      liveImage.style.display = "none";
    }

    lastDispatchId = data.timestamp;
  } catch (err) {
    console.error("Polling error:", err);
  }
}


function toggleSettings() {
  const panel = document.getElementById("settings-panel");
  panel.style.display = (panel.style.display === "none" || panel.style.display === "") ? "block" : "none";
}

loadPromptSets();
loadInitialHistory();
pollLatest();
setInterval(pollLatest, 5000);
</script>


</body>
</html>
